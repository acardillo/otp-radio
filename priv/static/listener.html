<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>OTP Radio - Listener</title>
    <style>
      :root {
        --bg: #0d0d0d;
        --panel: #1a1a1a;
        --accent: #00c853;
        --accent-dim: #00a843;
        --warn: #ffab00;
        --error: #ff1744;
        --text: #e0e0e0;
        --text-dim: #888;
      }
      * { box-sizing: border-box; }
      body {
        font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        padding: 24px;
        background: var(--bg);
        color: var(--text);
        max-width: 720px;
        margin: 0 auto;
      }
      h1 { font-size: 1.5rem; color: var(--accent); margin-bottom: 8px; }
      .status-bar {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 8px;
        margin-bottom: 20px;
      }
      .status-dot {
        width: 12px; height: 12px;
        border-radius: 50%;
        background: var(--text-dim);
        flex-shrink: 0;
      }
      .status-dot.live { background: var(--accent); box-shadow: 0 0 8px var(--accent); }
      .status-dot.buffering { background: var(--warn); animation: pulse 1s infinite; }
      .status-dot.reconnecting { background: var(--warn); animation: pulse 1s infinite; }
      .status-dot.failed { background: var(--error); }
      @keyframes pulse { 50% { opacity: 0.5; } }
      .status-text { font-size: 1rem; font-weight: 600; }
      .stats {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-bottom: 16px;
        font-size: 0.85rem;
        color: var(--text-dim);
      }
      .stats span strong { color: var(--text); }
      .controls { margin-bottom: 20px; }
      button {
        font-size: 0.95rem;
        padding: 12px 24px;
        background: var(--accent);
        color: #000;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-family: inherit;
        font-weight: 600;
      }
      button:hover:not(:disabled) { background: #00e064; }
      button:disabled { background: #444; cursor: not-allowed; color: #666; }
      button.secondary {
        background: transparent;
        color: var(--accent);
        border: 1px solid var(--accent);
      }
      audio { width: 100%; margin: 12px 0; }
      .section { margin-bottom: 20px; }
      .section h3 { font-size: 0.9rem; color: var(--text-dim); margin-bottom: 8px; }
      #log {
        height: 220px;
        overflow-y: auto;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 12px;
        background: #000;
        font-size: 0.8rem;
      }
      #log .error { color: var(--error); }
      #log .warn { color: var(--warn); }
      [data-tooltip]:hover::after {
        content: attr(data-tooltip);
        position: absolute;
        padding: 4px 8px;
        background: #333;
        color: #fff;
        font-size: 0.75rem;
        white-space: nowrap;
        border-radius: 4px;
        margin-top: 4px;
      }
    </style>
  </head>
  <body>
    <h1>OTP Radio – Station One</h1>

    <div class="status-bar" id="statusBar">
      <span class="status-dot" id="statusDot"></span>
      <span class="status-text" id="statusText">Ready</span>
    </div>

    <div class="stats" id="stats">
      <span>Buffer: <strong id="bufferSec">0</strong> s</span>
      <span>Chunks/s: <strong id="chunksPerSec">0</strong></span>
      <span>Latency: <strong id="latencyMs">—</strong></span>
      <span>Queue: <strong id="queueLen">0</strong></span>
    </div>

    <div class="controls">
      <button id="playBtn" data-tooltip="Connect and start playback">Start Listening</button>
      <button id="restartBtn" class="secondary" disabled data-tooltip="Reconnect and rebuffer">Restart stream</button>
    </div>

    <audio id="audioPlayer" controls></audio>

    <div class="section">
      <h3>Stream log</h3>
      <div id="log"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phoenix@1.7.10/priv/static/phoenix.min.js"></script>
    <script>
      // Latency: start playback with minimal buffer so latency stays <1s. MSE works with 200–300ms WebM chunks.
      const START_BUFFER_SEC = 0.2;
      const MAX_JITTER_QUEUE = 30;
      const LATENCY_SAMPLE_INTERVAL_MS = 500;

      const statusBar = document.getElementById('statusBar');
      const statusDot = document.getElementById('statusDot');
      const statusText = document.getElementById('statusText');
      const bufferSecEl = document.getElementById('bufferSec');
      const chunksPerSecEl = document.getElementById('chunksPerSec');
      const latencyMsEl = document.getElementById('latencyMs');
      const queueLenEl = document.getElementById('queueLen');
      const logEl = document.getElementById('log');
      const playBtn = document.getElementById('playBtn');
      const restartBtn = document.getElementById('restartBtn');
      const audioPlayer = document.getElementById('audioPlayer');

      let mediaSource, sourceBuffer, socket, channel;
      let chunkQueue = [];
      let isAppending = false;
      let chunkCount = 0;
      let lastSequence = -1;
      let droppedSequences = 0;
      let chunksInLastSecond = 0;
      let lastSecondTime = Date.now();
      let latencySampleIntervalId = null;

      function log(message, type = '') {
        const div = document.createElement('div');
        div.className = type;
        div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logEl.insertBefore(div, logEl.firstChild);
      }

      function setStatus(text, state) {
        statusText.textContent = text;
        statusDot.className = 'status-dot' + (state ? ' ' + state : '');
      }

      function updateStats() {
        const now = Date.now();
        if (now - lastSecondTime >= 1000) {
          chunksPerSecEl.textContent = chunksInLastSecond;
          chunksInLastSecond = 0;
          lastSecondTime = now;
        }
        queueLenEl.textContent = chunkQueue.length;
        if (sourceBuffer && sourceBuffer.buffered.length > 0) {
          const bufEnd = sourceBuffer.buffered.end(0);
          const bufStart = sourceBuffer.buffered.start(0);
          const current = audioPlayer.currentTime;
          const bufferedAhead = Math.max(0, bufEnd - current);
          bufferSecEl.textContent = bufferedAhead.toFixed(1);
        }
      }

      function estimateLatencyMs() {
        if (!sourceBuffer || sourceBuffer.buffered.length === 0) return null;
        const end = sourceBuffer.buffered.end(0);
        const current = audioPlayer.currentTime;
        return Math.round((end - current) * 1000);
      }

      function appendNextChunk() {
        if (isAppending || chunkQueue.length === 0) return;
        if (!sourceBuffer || sourceBuffer.updating) return;
        const chunk = chunkQueue.shift();
        if (!chunk) return;
        isAppending = true;
        try {
          sourceBuffer.appendBuffer(chunk.buffer);
        } catch (e) {
          log('Append error: ' + e.message, 'error');
          isAppending = false;
        }
      }

      function ensureMSE() {
        if (!window.MediaSource) {
          setStatus("Browser doesn't support streaming", 'failed');
          log("MediaSource Extensions not supported. Use Chrome, Firefox, or Safari.", 'error');
          return false;
        }
        const mime = 'audio/webm; codecs="opus"';
        if (!MediaSource.isTypeSupported(mime)) {
          setStatus("Codec not supported", 'failed');
          log('audio/webm; codecs=opus not supported in this browser.', 'error');
          return false;
        }
        return true;
      }

      function startListening() {
        if (!ensureMSE()) return;
        playBtn.disabled = true;
        setStatus('Opening stream...', 'buffering');
        mediaSource = new MediaSource();
        audioPlayer.src = URL.createObjectURL(mediaSource);

        mediaSource.addEventListener('sourceopen', () => {
          log('MediaSource opened');
          sourceBuffer = mediaSource.addSourceBuffer('audio/webm; codecs="opus"');
          if (sourceBuffer.mode !== undefined) sourceBuffer.mode = 'sequence';

          sourceBuffer.addEventListener('updateend', () => {
            isAppending = false;
            appendNextChunk();
            const bufSec = sourceBuffer.buffered.length > 0
              ? sourceBuffer.buffered.end(0) - audioPlayer.currentTime
              : 0;
            if (audioPlayer.paused && bufSec >= START_BUFFER_SEC) {
              audioPlayer.play().catch((e) => log('Play error: ' + e.message, 'error'));
              setStatus('Live', 'live');
            }
          });

          sourceBuffer.addEventListener('error', () => {
            log('SourceBuffer error', 'error');
            setStatus('Playback error', 'failed');
          });

          setStatus('Connecting...', 'buffering');
          connectSocket();
        });

        mediaSource.addEventListener('sourceended', () => setStatus('Stream ended', ''));
        mediaSource.addEventListener('sourceclose', () => {});
      }

      function connectSocket() {
        socket = new Phoenix.Socket('/socket', {});
        socket.onOpen(() => {
          log('WebSocket connected');
          setStatus('Joining channel...', 'buffering');
        });
        socket.onError(() => setStatus('Connection error', 'failed'));
        socket.onClose(() => {
          if (mediaSource && mediaSource.readyState === 'open') {
            setStatus('Reconnecting...', 'reconnecting');
          } else if (statusDot.classList.contains('live') || statusDot.classList.contains('buffering')) {
            setStatus('Disconnected', 'failed');
          }
        });

        channel = socket.channel('listener:one', {});
        channel.onClose(() => setStatus('Channel closed', 'failed'));
        channel.onError(() => setStatus('Channel error', 'failed'));

        socket.connect();

        channel
          .join()
          .receive('ok', () => {
            setStatus('Buffering...', 'buffering');
            log('Joined – receiving audio (buffer catchup + live)');
          })
          .receive('error', (resp) => {
            setStatus('Failed to join', 'failed');
            log('Join error: ' + JSON.stringify(resp), 'error');
            playBtn.disabled = false;
          });

        channel.on('audio', (payload) => {
          if (statusDot.classList.contains('reconnecting')) setStatus('Buffering...', 'buffering');
          chunkCount++;
          chunksInLastSecond++;
          const seq = payload.sequence != null ? payload.sequence : chunkCount - 1;
          if (lastSequence >= 0 && seq > lastSequence + 1) {
            droppedSequences += (seq - lastSequence - 1);
            log('Gap in sequence: ' + (lastSequence + 1) + '..' + (seq - 1), 'warn');
          }
          lastSequence = seq;

          const binaryString = atob(payload.data);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);

          chunkQueue.push({ buffer: bytes.buffer, sequence: seq });
          chunkQueue.sort((a, b) => a.sequence - b.sequence);
          if (chunkQueue.length > MAX_JITTER_QUEUE) {
            const removed = chunkQueue.splice(0, chunkQueue.length - MAX_JITTER_QUEUE);
            droppedSequences += removed.length;
          }
          appendNextChunk();
          updateStats();
        });
      }

      function startLatencySampling() {
        if (latencySampleIntervalId) return;
        latencySampleIntervalId = setInterval(() => {
          const ms = estimateLatencyMs();
          latencyMsEl.textContent = ms != null ? ms + ' ms' : '—';
        }, LATENCY_SAMPLE_INTERVAL_MS);
      }

      audioPlayer.addEventListener('playing', () => {
        setStatus('Live', 'live');
        restartBtn.disabled = false;
        startLatencySampling();
      });

      setInterval(updateStats, 500);

      playBtn.onclick = () => startListening();

      restartBtn.onclick = () => {
        if (latencySampleIntervalId) {
          clearInterval(latencySampleIntervalId);
          latencySampleIntervalId = null;
        }
        if (channel) channel.leave();
        if (socket) socket.disconnect();
        if (mediaSource && mediaSource.readyState === 'open') {
          try { sourceBuffer.abort(); } catch (_) {}
          try { mediaSource.endOfStream(); } catch (_) {}
        }
        audioPlayer.src = '';
        chunkQueue = [];
        isAppending = false;
        lastSequence = -1;
        chunksInLastSecond = 0;
        setStatus('Ready', '');
        bufferSecEl.textContent = '0';
        chunksPerSecEl.textContent = '0';
        latencyMsEl.textContent = '—';
        queueLenEl.textContent = '0';
        playBtn.disabled = false;
        restartBtn.disabled = true;
        setTimeout(() => startListening(), 200);
      };
    </script>
  </body>
</html>
